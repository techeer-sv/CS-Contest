1. **JavaScript에서 호이스팅(hoisting)이란 무엇인가요? `var`, `let`, `const` 선언이 호이스팅에서 어떻게 다르게 동작하는지 설명해주세요. 또한, 함수 선언과 함수 표현식에서의 호이스팅 차이점에 대해서도 설명해주세요.**

- 답 :

실제 코드가 배치되는건 아닌데 마치 변수나 함수선언이 코드의 상단으로 끌어올리는 것처럼 동작하는 JS만의 특징입니다.

var로 선언이 된다면 선언단계와 초기화 단계가 한번에 이루어져 런타임 이전에 접근 시 undefined로 변수가 초기화됩니다.
반면 let과 const는 선언단계와 초기화 단계가 분리되어서 스코프에 변수는 등록되지만 초기화 되지 않아 런타임 이전에 접근시 참조 에러가 발생하게됩니다.

함수 선언방식으로 정의된 함수는 함수 호이스팅이 발생해 (런타임 이전에 객체 생성) 어디서든 함수를 호출할 수 있게됩니다.
함수 표현식으로 정의된 함수는 변수 호이스팅 규칙을 따라 런타임 이전에는 undefined로 초기화되어 참조 시 TypeError가 발생합니다

<br>

---

2. **JavaScript에서 이벤트 루프가 비동기 작업을 어떻게 처리하는지 설명해주세요. 특히 마이크로 큐와 태스크 큐가 어떻게 관리되는지와, 이 두 큐에서 Promise와 setTimeout의 처리 우선순위에 대해서도 함께 설명해주세요.**

- 답 :

실행 스택이 비어 있고, 태스크 큐 또는 마이크로태스크 큐에 대기 중인 작업이 있을 때 이러한 작업을 스택으로 옮겨 실행합니다. 이를 계속 반복하며 비동기 작업을 처리합니다.

태스크 큐는 setTimeout, 사용자 상호작용 이벤트, 웹API, I/O 작업등의 콜백을 보관합니다.
마이크로큐는 Promise와 관련된 콜백과 MutationObserver의 콜백을 관리합니다.

이벤트 루프는 마이크로 큐를 우선적으로 접근하고 처리하므로 마이크로태스크인 Promise를 setTimeout보다 우선적으로 처리합니다.

<br>

---

3. **`this` 키워드가 JavaScript에서 어떻게 결정되는지 설명하고, 다양한 상황에서 `this`가 어떻게 바인딩되는지 예를 들어 설명해주세요.**

- 답 :

전역 컨택스트에서는 전역 객체를 참조합니다. (브라우저라면 window, Node라면 global)
함수가 일반적인 방식에서 호출된다면 기본적으로 전역 객체를 가리킵니다.

```javascript
// 객체의 메서드로써 호출될때는 메서드를 호출하는 객체에 바인딩
const obj = {
 value : 50
 show: function() {
    console.log(this.value);
  }
}
```

```javascript
// 화살표 함수를 사용하면 함수가 선언된 시점의 컨텍스트에 바인딩(상위 스코프 this가져옴)
const obj = {
 value : 50
  show: function() {
      const arrowFunc = () => {
        console.log(this.value); // 'this'는 상위 스코프의 'obj'를 참조
      };
      arrowFunc();
    }
}
```

```javascript
// new 키워드를 사용하여 함수를 생성자로 호출하면, this는 새로 생성된 객체에 바인딩
function Person(name) {
  this.name = name;
}
const person1 = new Person("John");
```

<br>

---

4. **JavaScript의 비동기 처리 방식인 콜백, 프로미스, async/await의 차이점은 무엇인가요? 각 방식의 기본 개념과 장단점을 설명해주세요.**

- 답 :

콜백은 함수를 props로 넘겨 특정 작업이 처리된 후 호출되도록 하는 방법입니다. 단순하고 높은 호환성의 장점이 있지만 코드의 가독성이 떨어지고 쉽지않은 에러처리와 콜백 지옥문제가 발생할 수 있습니다.

프로미스는 객체를 통해 비동기 작업의 결과와 상태를 표현할 수 있으며 `then()` `catch()`등의 메서드를 통해 콜백보다 일관적이고 높은 가독성의 처리가 가능합니다. 단 오래된 브라우저의 호환성문제나 체이닝이 길어질 수 있는 문제점이 있습니다.

async/await 는 항상 Promise를 반환하고 내부에서 프로미스의 경과를 기다려 높은 가독성의 특징과 `try/catch` 기반의 쉬운 에러처리가 가능합니다. 그러나 여러 비동기 작업을 동시에 처리하려면 주의가 필요합니다
