## **1. TCP와 UDP 각각의 개념을 설명하고, 둘의 차이를 비교해주세요.**

### **TCP란 무엇인가요?**

TCP(Transmission Control Protocol), 우리말로는 전송 제어 프로토콜 또는 전송조종규약 이라고 불리는 이 개념은 우리가 IP라고 부르는 인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나입니다. 주로 이 IP와 함께 TCP/IP라는 명칭으로도 널리 불리고 있으며 OSI 모델의 제 4계층에 해당하는 프로토콜로, 인터넷 프로토콜과 함께 구성되어있습니다.
주로 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간의 일련의 `옥텟`을 안정적으로, 순서대로, 에러없이 교환할 수 있도록 하는 역할을 수행합니다. 쉽게말해 "가장 널리 사용되는 정보 전달을 해주는 연결형 프로토콜"이라고 부를 수 있습니다.
TCP는 `데이터스트림`에서 데이터를 받아들이고 `청크 단위`로 분할합니다. 그리고 `TCP 헤더`를 덧붙여 `TCP 세그먼트`를 생성합니다. `TCP 세그먼트`는 `IP 데이터그램`에 `패킷화`되어 상대방과 주고 받게 됩니다. 그렇게 한 컴퓨터에서 다른 컴퓨터로 전송되는 모든 데이터가 오류나 결함 없이 올바른 순서로 성공적으로 수신되도록 합니다.

![](https://i.imgur.com/TAPkuj5.png)

- 옥텟이란?
  - 8 비트, 즉, 1 바이트를 의미합니다. 컴퓨터 네트워킹에서 표준 데이터 단위로 사용됩니다.
  - TCP에서도 데이터 전송의 기본 단위로 사용됩니다.
- 데이터스트림이란?
  - 연속적인 데이터의 흐름을 의미합니다(Data + Stream).
  - 일반적으로 파일, 데이터베이스 또는 네트워크로부터 읽거나 쓰는 데이터를 말합니다.
  - TPC는 이 데이터스트림을 효율적으로 전송하기 위해 사용됩니다.
- 청크 단위로 분할된 데이터는 어떻게 보일까?
  - 청크 단위로 분할된 데이터는 작은 데이터 블록으로 나뉩니다.
  - 각 청크는 독립적으로 전송되고, 목적지에서 다시 조립됩니다.
  - 이는 데이터를 더 관리하기 쉽고, 효율적으로 전송하기 위한 방법입니다.
- TCP 헤더란?
  - TCP 헤더는 TCP의 세그먼트의 시작 부분에 위치하며, 송신자 및 수신자의 여러 정보들을 포함합니다.
  - 이 정보들은 데이터 전송을 제어하고, 에러를 나타내는 데 중요한 역할을 합니다.
- TCP 세그먼트란?
  - TCP 헤더와 데이터 부분으로 구성된 패킷입니다.
  - 네트워크를 통해 전송되며, 목적지에서 TCP 헤더를 사용하여 다시 올바르게 조립합니다.
- IP 데이터그램이란?
  - IP 데이터그램은 인터넷 프로토콜(IP)을 통해 전송되는 패킷의 기본 단위입니다.
  - 각 데이터그램은 헤더와 데이터 부분을 포함하며, 네트워크를 통해 독립적으로 라우팅됩니다.
- 패킷화란?
  - 큰 데이터를 작은 패킷으로 나누는 과정을 말합니다.
  - 작은 패킷들은 네트워크를 통해 별도로 전송되며, 목적지에서 다시 조립되어 완전한 데이터로 복원됩니다.
  - 데이터 전송의 효율성을 높이고 네트워크의 혼잡함을 줄일 수 있으며, 데이터가 손상되거나 유실되었을 때 특정 부분만 재 전송할 수 있도록 해줍니다.

### TCP는 언제 사용되나요?

TCP(Transmission Control Protocol)는 주로 다음과 같은 상황들에서 사용됩니다.

1. 웹 브라우징
2. 이메일 전송
3. 파일 전송
4. 온라인 게임
   - 데이터 지연이 상대적으로 덜 중요한 게임
5. 원격 접속
   특히 신뢰성이 중요한 프로그램들에서 사용됩니다.
   이 TCP를 이용하면 데이터를 안정적으로 전송할 수 있습니다.

### UDP란 무엇인가요?

UDP(User Datagram Protocol), 사용자 데이터그램 프로토콜이라고 불리는 이 개념은
전달을 확인하고 순차 보장 기능이 없는 대신 `오버헤드`가 작고 지연시간이 짧다는 장점을 지니고 있습니다.
하지만 UDP는 단순한 전송방식을 가지고 있기 때문에 서비스의 신뢰성이 낮고, `데이터그램 도착 순서가 바뀌거나, 중복되거나, 심지어는 통보 없이 누락시키기도 합니다`.

- 오버헤드란?
  - 오버헤드는 특정 작업을 수행하기 위해 필요한 추가적인 시간 또는 리소스를 의미합니다.
  - UDP의 경우, TCP에 비해 오버헤드가 작다는 것은 데이터를 전송하는 데 필요한 추가적인 처리 시간과 리소스가 적다는 것을 의미합니다.
    - 이는 UDP가 연결 설정, 상태 유지, 에러 복구 등 복잡한 메커니즘을 갖추지 않기 때문입니다.
- 데이터그램 도착 순서가 바뀌거나, 중복되거나, 심지어는 통보 없이 누락시키는 예시는 무엇이 있을까?
  - 예를 들어, 실시간 스트리밍 중 일부 프레임이 늦거나 도착하지 않는 경우가 있습니다.
    - 네트워크 지연이나 혼잡으로 인해 발생할 수 있으며, UDP는 이러한 상황에 대해 복구 메커니즘을 제공하지 않습니다.

### UDP는 언제 사용되나요?

TCP와 함께 `데이터그램`으로 알려진 짧은 문장의 메세지를 교환하기 위해 사용됩니다.
주로 TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우에 사용합니다. DNS, IPTV, 음성 인터넷 프로토콜(VoIP), TFTP, IP 터널, 그리고 많은 온라인 게임 등에서 사용됩니다.

오디오, 비디오 스트리밍 서비스, 온라인 게임에서도 자주 사용되며, 실시간 성능이 매우 중요하며, 데이터 손실이 생겨도 괜찮은 서비스들에 사용됩니다.

- 데이터그램?
  - UDP는 짧은 메시지를 데이터그램 형식으로 전송합니다.
  - 데이터그램은 독립적인 패킷으로, 각각의 패킷이 독립적인 경로로 전송될 수 있습니다.
- DNS란?
  - 인터넷 도메인 이름을 IP 주소로 변환하는 시스템입니다.
  - 빠른 조회가 필요하기에 UDP를 사용합니다.
- IPTV란?
  - 인터넷 프로토콜을 사용하여 텔레비전 콘텐츠를 전송합니다.
  - 실시간 전송에 적합하므로 빠른 전송을 위해 UDP가 사용됩니다.
- 음성 인터넷 프로토콜(VoIP)이란?
  - 인터넷을 통해 음성 통신을 가능하게 하는 기술입니다.
  - 지연 시간을 최소화하기 위해 UDP를 사용합니다.
- IP 터널이란?
  - 한 네트워크를 다른 네트워크로 연결하는 데 사용되는 기술입니다.
  - 데이터 패킷을 캡슐화하여 전송하는 데 UDP가 사용될 수 있습니다.

### TCP와 UDP의 차이는 무엇인가요?

가장 큰 차이점은 데이터 신뢰성을 중시하는지, 속도(실시간)를 중시하는지 라고 볼 수 있습니다.
TCP는 연결형 프로토콜이기에 데이터 신뢰성을 중시하는 반면에 비 연결형 프로토콜인 UDP의 경우에는 신뢰성보다는 속도를 더 중요시하는 특징을 가집니다.
TCP는 데이터 재전송을 염두에 두고 데이터를 교환하는 반면 UDP는 이를 염두에 두지 않아 TCP보다 빠른 전송 속도를 가지고 있습니다.
예를 들어보면 TCP는 전화 통화와 같습니다. 양측 모두가 서로 통신할 준비가 되어있어야만 정보를 전달할 수 있습니다. 반대로 UDP는 무전과 같습니다. 통신 준비를 확인하지 않기도 하며, 상대가 없을 경우 데이터가 전송되지 않은 결과로 이어질 수도 있습니다.

**References**
[위키백과(TCP)](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)
[TCP/IP(전송 제어 프로토콜/인터넷 프로토콜)](https://m.blog.naver.com/ki630808/221859634986)
[용어사전](https://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EC%A0%84%EC%86%A1+%EC%A0%9C%EC%96%B4+%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)
[전송 제어 프로토콜이란 무엇인가요?](https://massive.io/ko/file-transfer/what-is-transmission-control-protocol-tcp/)
[사용자 데이터그램 프로토콜(UDP)](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)
[(Network) TCP와 UDP를 사용하기 위한 적절한 환경](https://prinha.tistory.com/entry/Network-TCP%EC%99%80-UDP%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%A0%81%EC%A0%88%ED%95%9C-%ED%99%98%EA%B2%BD)
[UDP, TCP 통신 예제](https://blog.koriel.kr/udp-tcp-tongsin-yeje/)
[전송 계층 프로토콜 TCP와 UDP](https://studycapitalism.com/tcp-udp%EC%A0%84%EC%86%A1%EA%B3%84%EC%B8%B5-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4%EC%A0%90/)
[TCP와 UDP 비교 정리](https://swalloow.tistory.com/77)

## 1-1. **TCP 연결 과정인 3-way handshake, 4-way handshake란 무엇인지, 그리고 각 과정에서 왜 단계 차이가 발생하는지 설명해주세요.**

3-way handshake와 4-way handshake는 TCP가 신뢰성 있는 데이터 전송을 보장하기 위해 사용하는 매커니즘입니다.

### 3-way handshake란 무엇인가요?

3-way handshake란 TCP/IP 프로토콜을 이용해 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터의 세션을 사전에 먼저 수립하는 과정입니다.
양쪽 모두 데이터를 전송할 준비가 되어있다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 다른 쪽에서 준비되었다는 것을 알 수 있도록 해줍니다.

1. 클라이언트가 서버에게 연결 요청(SYN)
   - 클라이언트는 SYN 패킷을 보내고, SYN_SENT 상태가 됨
2. 서버는 클라이언트의 요청을 수신(SYN/ACK)
   - 연결을 수락한다는 ACK(ACKnowledgment)와 함께 자신의 SYN 패킷을 보냄
   - 서버는 SYN_RECEIVED 상태가 됨
3. 클라이언트는 서버의 SYN/ACK에 대해 ACK를 보냄
   1. 이후부터는 양쪽 모두 데이터를 주고받을 수 있는 ESTABLISHED 상태가 됨

위와 같은 세 과정을 통해 진행되며 TCP 접속을 성립하기 위해 반드시 필요한 과정이라고 볼 수 있습니다.

### 4-way handshake란 무엇인가요?

3-way handshake가 데이터를 전송하기 위해 세션을 수집하는 과정이었다면 4-way handshake는 반대로 세션을 종료하기 위해 수행되는 절차입니다. 그리고 아래와 같은 과정을 통해 이루어집니다.

1. 클라이언트의 연결 종료 요청 FIN 플래그를 사용하여 서버에 알림
2. 서버는 클라이언트에서 보낸 FIN 요청을 받고 ACK를 보내 클라이언트의 요청을 확인
   - 서버 자체의 모든 데이터가 전송되기 전까지 기다리며 TIME_WAIT 상태가 됨
3. 서버의 모든 데이터 전송이 완료되면 서버에서 클라이언트에게 FIN 플래그를 보냄
4. 클라이언트는 서버의 FIN에 대해 ACK를 보내고 완전하게 연결이 종료된다.

### 각 과정에서 왜 단계 차이가 나는 것일까요?

가장 큰 차이는 두 과정의 시점에 있습니다.
3-way handshake는 전송을 시작하기 위한 연결 시작 과정이고, 양쪽이 준비되었다는 것을 두 단계만으로 확인할 수 있다는 특징을 가지고 있습니다.
반면 4-way handshake는 서버와 클라이언트 모두에서 전송할 데이터가 없어야 한다는 것을 확인하는 과정이 들어가야 하는 연결을 종료하는 과정입니다.
여기서 "더 이상 전송할 데이터가 없어야 한다"를 만족시키기 위해 접속을 종료하기 전 한 단계가 더 들어간다는 것을 볼 수 있습니다.

그렇게 추가적인 단계를 수행하면서 TCP의 특징 중 하나인 "신뢰성 있는 데이터 전송"을 보장받게 됩니다.

**References**
[3-way handshake, 4-way handshake](https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake)
[TCP와 3-Way, 4-Way Handshake란? (개념/ 동작 방식)](https://jeongkyun-it.tistory.com/180)
[(네트워크) TCP/UDP와 3 -Way Handshake & 4 -Way Handshake](https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake)
[(네트워크 network) TCP 3-way HandShake & 4-way HandShake](https://resilient-923.tistory.com/392)

---

## 2. **CORS란 무엇이고, 어떻게 구현할 수 있는지 최대한 자세하게 설명해주세요.**

### CORS(Cross-Origin Resource Sharing)란 무엇인가요?

CORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유)는 서로 다른 출처의 자원들을 공유한다는 뜻으로, 웹페이지가 다른 도메인의 리소스에 접근할 수 있도록 허용하는 보안 메커니즘입니다. 웹 보안 정책인 Same-Origin Policy에 의해, 브라우저는 기본적으로 다른 출처(Origin)의 서버로 HTTP 요청을 보내는 것을 제한합니다. 여기서 '출처'는 프로토콜, 도메인, 포트 번호의 조합을 의미합니다.

아래와 같은 URL이 있다고 가정해봅시다

- `https://` `time-map-installer.tistory.com` `:352` `/265` `?page=1` `#Personal`

이 URL의 구성을 보고 정리를 해보자면 다음과 같다고 볼 수 있습니다.

- `https://` : Protocol
- `time-map-installer.tistory.com` : Host
- `:352` : Port(생략 가능)
- `/265` : Path
- `?page=1` : Query String
- `#Personal` : Fragment

이걸 왜 정리했냐 한다면 바로 동일 출처가 무엇인지를 설명하기 위함입니다.
여기서 동일 출처(Origin)는 "Protocol + Host + Port"가 같다면 동일 출처라고 합니다.

그렇게 `http://example.com`의 웹 페이지가 `http://api.different.com`에서 데이터를 요청하려 할 때, 이는 다른 출처의 URL로 요청을 보내는 것이므로 cross-origin 요청으로 간주됩니다. CORS는 브라우저의 리소스를 다른 Origin으로부터 로드하지 못하게 하면서 이러한 요청을 안전하게 수행할 수 있도록 해줍니다. 서버는 특정 HTTP 헤더를 통해 브라우저에게 다른 출처의 요청을 허용할지 여부를 알려줍니다.

### CORS의 작동 방식은 무엇인가요?

CORS의 작동 방식은 크게 세 가지로 나뉩니다. 단순요청인 Simple Request, 안전성을 미리 검사하는 Preflight Request, 그리고 신뢰할 수 있는지에 대한 Credentialed Request로 나뉘어 있습니다.

1. Simple Request

   1. 서버로 요청을 한다.
   2. 서버의 응답이 왔을 때, 브라우저에서 요청한 Origin과 Access-Control-Request-Header의 값을 비교하여 유효한 요청이면 응답하고, 유효하지 않은 요청이라면 에러를 발생한다.

   - 가능한 HTTP method
     - GET, HEAD, POST 요청만 가능하다.
   - 가능한 Content-Type
     - application/x-www-form-urlencoded
     - multipart/form-data
     - text/plain

2. Preflight Request

   1. **Preflight 요청 보내기** : 브라우저는 서버에 `OPTIONS` 메서드를 사용하여 특별한 요청을 보낸다. 이 요청에는 실제 보내려는 요청의 정보가 담긴 헤더가 포함된다.
      - Origin : 어디서 요청을 했는 지 서버에 알려주는 주소
      - Access-Control-Request-Method : 실제 요청이 보낼 HTTP 메서드
      - Access-Control-Request-Headers : 실제 요청에 포함된 header
   2. **브라우저의 검사** : 서버의 응답을 받은 브라우저는 이 정보를 검토하여 요청이 안전한지 확인한다.
      - **유효한 요청일 경우** : 브라우저는 실제 요청을 서버에 보낸다.
      - **유효하지 않은 요청일 경우** : 브라우저는 요청을 중단하고 에러를 발생시킨다.

   - 서버의 응답 헤더
     - Access-Control-Allow-Origin `<origin>`
       - 해당 출처의 접근을 허용할지를 결정한다.
       - 모든 출처를 허용하려면 `*`를 사용한다. <- 마치 프로그래밍의 `Import *` 같은 느낌이다.
     - Access-Control-Expose-Headers `<headers>`
       - 브라우저가 접근할 수 있는 서버의 특정 헤더를 명시한다.
     - Access-Control-Max-Age `<seconds>`
       - preflight 요청의 결과를 얼마나 오랫동안 캐시할지를 지정한다.
     - Access-Control-Allow-Credentials
       - 쿠키와 같은 요소들이 있는 요청에 대한 응답을 브라우저가 읽을 수 있게 할지를 결정한다.
     - Access-Control-Allow-Methods `<methods>`
       - 실제 요청에서 허용되는 HTTP 메서드를 나타낸다.
     - Access-Control-Allow-Headers `<headers>`
       - 실제 요청에서 사용할 수 있는 HTTP 헤더를 나타낸다.

3. Credentialed Request
   - 사용자의 인증 정보(예: 쿠키, HTTP 인증 헤더, TLS 클라이언트 인증서)를 포함하여 다른 출처로 HTTP 요청을 보내는 것
   - 기본적으로, CORS 정책은 보안상의 이유로 다른 출처의 요청에 이러한 인증 정보를 포함하는 것을 허용하지 않으며, 아래와 같은 조건들을 만족시켜야 가능하다.
   1. **클라이언트 설정**: 클라이언트 측에서 요청을 보낼 때, `withCredentials` 속성을 `true`로 설정해야한다.
   2. **서버 설정**: 서버는 `Access-Control-Allow-Credentials` 헤더를 `true`로 설정하여 인증 정보 포함 요청을 허용해야 하며, `Access-Control-Allow-Origin` 헤더에 구체적인 출처를 명시해야 한다.

### CORS(Cross-Origin Resource Sharing)는 어떻게 구현할 수 있나요?

이를 구현하기 위해서는 클라이언트 측과 서버 측 양쪽 모두에서 설정을 해주어야 합니다.

우선 클라이언트 측의 설정입니다.
클라이언트 측에서는 아래와 같이 Origin 필드를 추가해야 합니다.

```
Origin: https://xxx.co.kr
```

그리고 이를 XMLHttpRequest(XHR), Fetch API, Axios 중 어떤 것을 사용하느냐에 따라 조금씩 다르게 설정이 됩니다.

1. XMLHttpRequest(XHR) 사용 시
   - withCredentials 속성을 true로 설정하여 쿠키와 인증 헤더를 포함할 수 있다.

```js
var xhr = new XMLHttpRequest();
xhr.open("GET", "https://xxx.co.kr", true);
xhr.withCredentials = true;
xhr.send(null);
```

2. Fetch API 사용 시
   - cors mode를 설정할 필요가 있다.
   - 여기서도 credentials 옵션을 include로 설정하여 쿠키와 인증 헤더를 포함할 수 있다.

```javascript
fetch("https://xxx.co.kr", {
  method: "GET",
  mode: "cors",
  credentials: "include", // 쿠키를 포함하기 위해 설정
});
```

3. Axois 사용 시
   - XHR의 방법처럼 withCredentials를 true로 설정하여 쿠키와 인증 헤더를 포함할 수 있다.

```js
axios.get("https://xxx.co.kr", {
  withCredentials: true,
});
```

클라이언트의 설정이 모두 끝났다면 다음은 서버 측에서 설정을 해야합니다.
설정할 CORS 헤더는 위의 Preflight Request에서 다룬 서버의 응답 헤더와 같습니다.

Node.js의 Express 프레임워크를 사용할 경우 다음과 같이 구현할 수 있습니다.(GPT 생성)

```javascript
const express = require("express");
const cors = require("cors");

const app = express();

app.use(
  cors({
    origin: "https://xxx.co.kr", // 특정 출처 허용
    methods: "GET,POST", // 허용할 메서드
    credentials: true, // 쿠키 허용
    allowedHeaders:
      "X-Requested-With, Origin, X-Csrftoken, Content-Type, Accept",
  })
);

app.get("/", function (req, res, next) {
  res.json({ msg: "This is CORS-enabled for only https://xxx.co.kr." });
});

app.listen(80, function () {
  console.log("CORS-enabled web server listening on port 80");
});
```

**References**
[CORS란 무엇인가?](https://hannut91.github.io/blogs/infra/cors)
[CORS란 무엇인가?](https://escapefromcoding.tistory.com/724)
[CORS란 무엇인가?](https://velog.io/@pwk921110/CORS%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)
[CORS 개념 정리(preflight, simple, credentialed request)+SOP](https://velog.io/@wiostz98kr/CORS%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83)
[Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
[CORS(Cross-origin Resource Sharing)의 구현](https://velog.io/@josworks27/CORS-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95)
[교차 출처 리소스 공유 (CORS)](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)
[🌐 악명 높은 CORS 개념 & 해결법 - 정리 끝판왕 👏](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-CORS-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%F0%9F%91%8F)
[CORS의 이해와 올바른 구현을 위한 가이드](https://pallycon.com/ko/blog/cors%EC%9D%98-%EC%9D%B4%ED%95%B4%EC%99%80-%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B5%AC%ED%98%84%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B0%80%EC%9D%B4%EB%93%9C/)
[CORS에서 이기는 방법](https://ui.toast.com/weekly-pick/ko_20211110)

---

## 3. **https://google.com을 입력했을 때 생기는 일에 대해 설명해주세요.**

🔥CS를 거의 몰랐던 상태의 제가 이해할 수 있도록 스토리텔링을 기반으로 작성한 글임을 알립니다.🔥
우리는 지금부터 https://google.com을 입력했을 때 벌어지는 일을, 해외의 한 도시로 여행을 떠나는 것에 빗대어 알아보도록 하겠습니다.
"**https://google.com**"을 입력했을 때 벌어지는 일련의 과정을 쉽고 재미있게 설명해보겠습니다. 이 과정을 "도시로의 여행"이라고 상상해볼까요?

### 1. **도메인 IP 주소 조회 : '여행 어디로 가지?'**

- 브라우저는 "https://google.com"이라는 도메인이 실제로 어디있는지에 대한 '주소'를 찾아야 합니다. 이는 마치 여행을 가기 전에 '여행지의 정확한 위치'를 찾는 것과 같습니다.
  - 예를 들어 미국의 실리콘밸리에 가고 싶다면 실리콘밸리가 미국의 어느 위치에 있는 지를 알아야 합니다.
- 브라우저는 이전에 방문했던 장소들(브라우저 캐시), 여행 계획 책자(OS 캐시), 지역 안내소(라우터 캐시), 그리고 국가 관광 정보 센터(ISP 캐시) 순으로 여행지 정보를 찾습니다.
  - 마치 지금까지 여행 다녔던 곳들을 기억해보다가, 관련 책자를 살펴보다가, 해당 지역을 검색했을 때 나오는 사이트에서 정보를 찾아보다가, 관광지를 잘 정리해둔 사이트에 들어가서 여행지를 찾는 것과 같죠.
- 만약 이 모든 곳에서 정보를 찾지 못한다면, 브라우저는 '모든 인터넷 검색 결과 탐색'(DNS 서버)를 통해 여행지의 정확한 위치를 찾습니다.
  - 반복적으로, 계속해서, 찾을 수 있을 때까지 반복하는 과정을 거쳐 결국에는 찾아내거나, 지명이 바뀌었거나 하는 등을 알아내는 과정과 같습니다.

### 2. **DNS 쿼리 : '모든 인터넷 검색 결과 탐색'**

- DNS 쿼리는 여행지를 찾기 위해 세계 여러 나라의 정보를 가지고 있는 인터넷에 계속해서 묻고 다니는 것과 같습니다. 이 과정을 '재귀적 질의'라고 부릅니다.
- 마침내 '여행지'(IP 주소)를 찾으면 목적지가 결정되면서 여행을 시작할 수 있습니다.

### 3. **TCP 연결: '비행기를 타고 갈까? 배를 타고 갈까?'**

- 이제 브라우저는 '여행 경로'(TCP 연결)를 설정합니다. 마치 비행기 티켓을 구매하고, 공항에 가서 비행기를 타는 것과 같습니다. 혹은 배를 타고 바다를 건너서 가는 방법도 있죠.
- 'TCP의 3-way handshake'는 비행기나 배에 탑승하기 전에 하는 탑승권을 확인하고 좌석을 배정하는 과정이라고 볼 수 있습니다.

### 4. **HTTP 요청: '여권과 비자는 제대로 준비해 오셨죠?'**

- 드디어 목적지인 미국에 도착했습니다. 도착하고 안내원에게 '여행지 정보'(웹 페이지 데이터)를 달라고 요청합니다. 만약 HTTPS를 사용한다면, 그 유명한 입국심사와 여권, 비자 확인과 같은 보안 절차를 거치는 것과 유사합니다.
- 이 때, 서버는 '관광 안내소'와 같으며, 우리가 원하는 정보(웹 페이지)를 제공합니다.

### 5. **서버의 응답: '안내소에서 정보 받기'**

- 서버는 요청한 웹 페이지 데이터를 브라우저에게 전달합니다. 이는 관광 안내소에서 지도와 안내 책자를 받는 것과 같습니다.

### 6. **콘텐츠 렌더링: '이제 여행을 즐겨보자!'**

- 마지막으로, 브라우저는 받은 데이터(HTML, CSS, JavaScript 등)를 해석하고 화면에 표시합니다. 마치 여행지에서 볼거리, 먹거리, 즐길거리를 체험하는 것과 같습니다.

### + **브라우저에서 나가기 '이제 안전하게 돌아가야겠다'**

위에서 TCP의 3-way handshake만을 다루고 있길래 4-way handshake는 언제 이루어지는 지 궁금해서 찾아보았습니다. 마침 브라우저에서 나가기를 누른다면 어떻게 될 지 궁금해서 한 번 찾아보았고, 이 때 4-way handshake를 통해 연결이 종료가 되는데요, 간단하게 정리하다면 다음과 같습니다. (이후 GPT사용)

1. **여행 종료 알림 (FIN):** 여행이 끝나갈 때, 여러분은 '여행지'(서버)에 여행을 마치고 집으로 돌아가겠다는 의사를 전달합니다. 컴퓨터 네트워킹에서, 이는 클라이언트가 서버에 연결 종료를 요청하는 FIN 플래그를 보내는 것과 같습니다.
2. **여행지의 응답 (ACK):** 여행지(서버)는 여러분의 '여행 종료 요청'을 받고, 그 요청을 확인합니다. 이때 서버는 자신의 모든 정보(데이터) 전송이 완료되었는지 확인하며, 여행자(클라이언트)에게 '확인 응답'(ACK)을 보냅니다.
3. **여행지의 종료 준비 (FIN):** 서버가 모든 정보를 전송하고 나면, 이제 서버도 여행 종료를 준비합니다. 서버는 여행자(클라이언트)에게 자신도 여행 종료 준비가 완료되었다는 신호(FIN)를 보냅니다.
4. **최종 확인 (ACK):** 여행자는 서버의 '여행 종료 준비 완료' 신호를 받고, 이를 확인하는 마지막 메시지(ACK)를 보냅니다.

**References**
[(AWS 문서)웹 브라우저에 URL을 입력하면 어떤 일이 생기나요?](https://aws.amazon.com/ko/blogs/korea/what-happens-when-you-type-a-url-into-your-browser/#:~:text=%EC%9B%B9%20%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80%20%EC%84%9C%EB%B2%84%EC%97%90,%EB%B0%8F%20%EB%B3%B8%EB%AC%B8%EC%9D%B4%20%ED%8F%AC%ED%95%A8%EB%90%A9%EB%8B%88%EB%8B%A4.)
[브라우저에 url을 입력하면 어떤일이 벌어질까?](https://velog.io/@khy226/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-url%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%95%98%EB%A9%B4-%EC%96%B4%EB%96%A4%EC%9D%BC%EC%9D%B4-%EB%B2%8C%EC%96%B4%EC%A7%88%EA%B9%8C)
[웹 브라우저에 URL을 입력하고 사용자에게 보여주기까지 과정](https://sunrise-min.tistory.com/entry/%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-URL%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%95%98%EA%B3%A0-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%97%90%EA%B2%8C-%EB%B3%B4%EC%97%AC%EC%A3%BC%EA%B8%B0%EA%B9%8C%EC%A7%80-%EA%B3%BC%EC%A0%95)
[(네트워크) 주소창에 URL을 입력 시 일어나는 일](https://oozoowos.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-URL%EC%9D%84-%EC%9E%85%EB%A0%A5-%EC%8B%9C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC)
[브라우저에 google.com을 치면 일어나는 일들](https://brunch.co.kr/@seungjoonlernnx/100)
[(웹 브라우저) 브라우저에 www.google.com을 치면 일어나는 일](https://leeph.tistory.com/39)
[웹 브라우저에 URL을 입력했을 때 발생하는 일](https://sorjfkrh5078.tistory.com/65)

---

## 4. **HTTP 1.1, 2.0, 3.0에 대해 각각 설명해주세요.**

### HTTP 1.1: HTTP 프로토콜의 첫 번째 공식 표준 버전

부제: 1차선 고속도로의 등장

> 잠깐만요, HTTP 1.0은요?

1.1 버전이 첫 번째 공식 표준 버전인 이유는 웹 통신의 기능을 크게 확장하고 최적화한 첫 번째 버전이기 때문입니다.
1.0 버전은 기본적인 웹 문서 전송에만 초점을 맞추었기에 여러 제한점이 생길 수 밖에 없었습니다.
따라서 기존의 HTTP 0.9와 HTTP 1.0의 기능을 확장하고 최적화하기 위해 생긴 버전이 1.1이며, 시간이 흘러 지금은 웹 통신의 표준 첫 번째로 소개됩니다.

#### 주요 특징

- **지속적 연결(Keep-Alive)**
  - 하나의 TCP 연결을 통해 여러 HTTP 요청과 응답을 전송할 수 있게 되었습니다.
  - 연결을 재사용할 수 있게 되었기에 네트워크 지연을 줄이고 전체적인 웹 페이지 로딩 속도를 향상시키는 데 기여했습니다.
  - 마치 단방향이었던 도로에 갈림길이 생겼다고도 볼 수 있죠.
- **파이프라이닝**
  - 여러 HTTP 요청을 연속적으로 전송할 수 있게 해줍니다.
  - 서버가 이전 요청을 완료하지 않았더라도 다음 요청을 처리할 수 있게 합니다.
  - 예를들어보자면 결제 창구가 있는 고속도로의 시작점을 생각해보면 될 것 같습니다.
    - 물론 결제 창구가 하나밖에 없긴 하지만 말이죠.
- **HTTP 메서드 추가**
  - 기존에 가지고 있던 GET, POST 외에도 PUT, DELETE, OPTIONS와 같은 메서드들이 도입되었습니다.
  - 웹의 기능성이 크게 향상되어 더욱 다채로운 기능을 구현하게 되었습니다.
- **청크 전송(Chunked Transfer Encoding)**
  - 서버가 응답의 전체 크기를 미리 알지 못하더라도 그 응답을 청크 단위로 나누어 순차적으로 전송할 수 있게 합니다.
  - 실시간으로 생성되는 컨텐츠의 전송에 매우 유용합니다.

#### 문제점

- **Head-of-Line Blocking**
  - 단일 연결에서 요청이 순차적으로 처리되어야 하여 생겨난 문제입니다.
  - 하나의 연결에서 발생하는 지연이 다른 모든 요청에 영향을 미치는 문제가 있습니다.
  - 아까 이야기했던 하나의 결제 창구를 가진 고속도로의 입구에서 한 손님이 잔돈을 꺼내느라 많은 시간을 소요할 때 주로 이런 현상이 발생하죠.
- **TCP 연결 오버헤드**
  - 연결을 재사용할 수 있게 되었음에도, 동시에 많은 리소스를 요청하게 된다면 그 한계를 넘어선 연결이 필요할 수 있습니다.
  - 특히 많은 리소스를 요구하는 웹페이지에서 성능이 저하되는 결과로 이어질 수 있다는 문제를 가지고 있습니다.
    - 쇼핑몰, SNS, 스트리밍, 대형 포털 등등

### HTTP 2.0: 더욱 복잡해지는 웹페이지

부제: 고속도로가 더욱 넓어졌다?

> 그래서 위에 나온 문제점들을 해결하기 위해 2.0이 나왔다는 거죠?

맞습니다. 그리고 이를 해결하기 위해 도입한 것은 "복잡성을 증가시키는 것"이었죠!
물론 이유없이 복잡해지기만 한다면 그건 실패한 업데이트 였을겁니다. 복잡성을 증가시킨데는 그 이유가 있었죠.

1. 웹페이지는 이렇게 변했습니다.
   - 단순한 텍스트 + 기본 이미지
   - 에서
   - 고해상도 이미지 + 고해상도 비디오 + 복잡한 스크립트 + 다양한 스타일시트 + AJAX 요청 등
   - 으로요!

> 복잡한 스크립트라는 건 분명 자바스크립트일텐데, 그 이전엔 단순한 HTML과 CSS뿐이었다는 소리인가요?

정답입니다! HTML 2.0 이전까지만 해도 단순한 HTML과 CSS로 구성되어있었습니다.
주로 웹 페이지는 정적인 콘텐츠를 표시하는 데 사용되었고, CSS는 기본적인 스타일링만을 제공했죠.
따라서 지금 우리가 보고 있는 수많은 사용자와 상호작용하고 있는 수수하고 화려한 수많은 페이지들은 HTTP 2.0이 등장하기 전까지만 해도 존재하지 않았다는 것을 의미합니다!

2. 또한 성능이 더욱 좋아졌습니다.
   - 더 빠른 페이지 로드시간
   - 즉각적인 상호작용
   - 실시간 업데이트
   - 모바일 + 크로스 브라우징 최적화
     - (이건 비밀인데, 1.1 => 2.0으로 가는동안 브라우저 전쟁이 일어났었답니다)

결국 HTTP 2.0은 HTTP 1.1의 성능을 더 좋게 만들고 더 효율적으로 데이터를 전송하기 위해 개발되었다고 봐도 무방합니다.

#### 주요 특징

- **멀티플렉싱(Multiplexed Streams)**
  - 하나의 TCP 연결에서 여러 요청과 응답이 동시에 이루어지도록 하면서 여러 요청이 서로에게 영향을 미치지 않고 동시에 처리될 수 있습니다.
  - 따라서 네트워크 지연이 줄어들고 성능이 향상되었습니다.
  - 고속도로가 단방향 1차선이었던 HTTP 1.1과는 다르게 이제 왕복 N차선이 된 것이죠!
- **스트림 우선순위**
  - 페이지의 중요한 부분을 먼저 로드할 수 있도록 요청에 우선순위를 지정할 수 있습니다.
  - 이는 페이지의 핵심 콘텐츠를 사용자에게 빠르게 전달하는 데 도움이 됩니다.
  - 예를들어 동영상 스트리밍 플랫폼이 있다면 지금 보려는 영상을 최우선으로 로드하는 것과 같습니다.
- **헤더 압축**
  - 헤더의 정보를 압축해서 전송하기 시작하면서 전송되는 데이터의 양을 줄이고 성능이 향상되었습니다.
- **서버 푸시**
  - 서버가 클라이언트의 요청을 기다리지 않고 일방적으로 필요한 리소스를 보내는 기능입니다.
  - 리소스 로딩 시간을 줄이고 사용자 경험을 향상시킵니다.

> 이렇게 복잡성을 증가시켜 많은 것들을 개선해내었지만, 오히려 복잡성이 이제는 문제가 되고 있는 상황입니다.

멀티플렉싱, 헤더 압축과 같은 새로운 기능으로 인해 복잡성이 증가하게 되었습니다.
왜냐하면 이 기능들로 인해 서버와 클라이언트에서 추가적인 로직과 처리 과정이 필요해졌기 때문이죠.
특히, 멀티플렉싱의 경우 여러 요청과 응답을 동시에 관리해야 하므로, 구현과 유지 관리가 더 복잡해질 수 있습니다.

> 이거 듣다보니 뭔가 비동기 처리가 떠오르는데, 멀티플렉싱이 비동기 처리인건가요?

사실 멀티플렉싱이 비동기처리라기 보다는 "멀티플렉싱이 등장함으로 인해 비동기 처리를 가능하게 한 것이 맞다"라고 보면 될 것 같습니다. 비동기 처리는 서버 또는 클라이언트에서 처리하는 "로직"이지, HTTP에 영향을 주는 "기능"은 아니기 때문이죠.

그렇게 현재 가장 많이 사용되고 있는 수많은 웹페이지와 브라우저의 HTTP 버전은 2.X버전이며, 이를 개선하기 위해 다음 버전이 개발되었습니다.

### HTTP 3.0:

> 그렇게 HTTP 2.0의 복잡성을 해결하기 위해 등장한 HTTP 3.0입니다. TCP 대신 UDP를 사용하여 핸드쉐이크로 발생하는 지연 시간을 감소시키고자 하였습니다.

#### 주요 특징: 빠르다, 그리고 TCP를 쓰지 않는다?

- UDP 기반의 QUIC 프로토콜을 사용합니다.

HTTP 3.0은 전통적인 방식인 TCP 대신 UDP를 기반으로 하는 QUIC 프로토콜을 사용합니다.
QUIC은 TCP와는 다르게 연결에 필요한 라운드 트립(Round Trip)을 줄이고, 패킷 손실 발생 시 빠르게 복구할 수 있도록 해줍니다.

> 하지만 TCP를 써야 손실 복구가 가능한 것 아닌가요?

놀랍게도 QUIC는 TCP처럼 패킷 손실을 복구할 수 있는 매커니즘이 있습니다.
UDP는 기본적으로 패킷 손실 복구 기능을 내장하고 있지 않지만, 이를 기반으로 하는 QUIC는 이를 프로토콜 수준에서 구현하여 신뢰성 있는 통신을 제공합니다.

- **연결 레이턴시 감소**: 1RTT(1 응답 시간)만에 연결을 설정할 수 있습니다.
  - 그리고 이미 연결된 서버라면 0RTT로 더욱 빨라지죠.

여기서 **1RTT**의 RTT(Round Trip Time)는 "클라이언트에서 서버로 데이터를 보내고, 그 응답이 돌아오는 데까지 걸리는 시간"입니다. 왕복 달리기의 1회 왕복 기록과 같죠.
HTTP/3의 QUIC 프로토콜은 초기 연결 설정에 단 하나의 RTT만 필요로 합니다.
그렇게 기존의 TCP보다 빠르게 연결을 수립할 수 있다는 것을 의미합니다.

- **패킷 손실 감지 시간 단축**: 각 패킷에 고유 번호를 할당하여 손실 감지 시간을 줄입니다.

패킷이 손실되면 데이터 전송에 지연이 발생할 수 있습니다.
HTTP 3.0의 QUIC 프로토콜은 각 패킷에 고유 번호를 부여하기에 어떤 패킷이 손실되었는지 빠르게 감지할 수 있습니다.
그리고 해당 패킷만을 재전송하여 전체 연결 성능이 저하되지 않도록 최소화합니다.

- **클라이언트 IP 변경 시 연결 유지**: 사용자의 IP가 변경되어도 기존의 연결을 유지할 수 있습니다.

특히 모바일 사용자에게 유용한 특징입니다.
사용자가 와이파이에서 데이터로, 데이터에서 와이파이로, 와이파이에서 다른 와이파이로 어떻게 변경을 해도 기존의 연결을 유지할 수 있어서 다시 연결될 때 발생할 수 있는 지연을 방지합니다.

#### 문제점 : 아직 적용되기엔 이른 버전!

1. **보편적 호환성**
   - 모든 브라우저나 서버가 아직 HTTP/3를 지원하지 않습니다.
2. **새로운 구현 필요**
   - QUIC 프로토콜은 기존의 TCP 기반 인프라와 다릅니다.
   - 따라서 이를 지원하기 위한 새로운 구현과 테스트가 필요합니다.

**References**
[HTTP 1.1 vs HTTP 2.0 vs HTTP 3.0](https://velog.io/@kcwthing1210/HTTP-1.1-vs-HTTP-2.0-vs-HTTP-3.0)
[HTTP/1.1과 HTTP/2.0, 그리고 간단한 HTTP/3.0](https://github.com/dongkyun-dev/TIL/blob/master/web/HTTP1.1%EA%B3%BC%20HTTP2.0%2C%20%EA%B7%B8%EB%A6%AC%EA%B3%A0%20%EA%B0%84%EB%8B%A8%ED%95%9C%20HTTP3.0.md)
[HTTP 1.0 VS 1.1 vs 2.0 vs 3.0](https://simgee.tistory.com/28)
[**HTTP/2, 제대로 이해하기**](https://gngsn.tistory.com/99)
[🌐 HTTP 2.0 소개 & 통신 기술 알아보기](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-20-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
[🌐 HTTP 3.0 소개 & 통신 기술 알아보기](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-30-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
[HTTP/3란?](https://www.cloudflare.com/ko-kr/learning/performance/what-is-http3/)
[패킷 손실 해결 방법](https://www.intel.co.kr/content/www/kr/ko/gaming/resources/how-to-fix-packet-loss.html#:~:text=%ED%8C%A8%ED%82%B7%20%EC%86%90%EC%8B%A4%20%EC%9D%B4%EB%9E%80%20%EC%BB%B4%ED%93%A8%ED%84%B0%EC%99%80,%ED%95%98%EB%AF%80%EB%A1%9C%20%EC%A7%80%EC%97%B0%EC%9D%B4%20%EB%B0%9C%EC%83%9D%ED%95%A9%EB%8B%88%EB%8B%A4.)
[(AWS)네트워킹 RTT란 무엇인가요?](https://aws.amazon.com/ko/what-is/rtt-in-networking/)
[(Protocol) QUIC 프로토콜이 뭐지?](https://musclebear.tistory.com/51)
[Latency/RTT/RTD란?](https://2infinity-and-beyond.tistory.com/2)
[입출력 다중화 (I/O) Multiplexing](https://plummmm.tistory.com/68)
