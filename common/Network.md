1. **TCP와 UDP 각각의 개념을 설명하고, 둘의 차이를 비교해주세요.**

- TCP는 패킷 사이의 순서를 보장하며 신뢰성/정확성을 우선시하는 연결형 통신 방식을 사용하는 프로토콜입니다. ‘가상회선 패킷 교환 방식’을 사용합니다. 서버와 클라이언트는 1:1로만 연결됩니다.
- UDP는 효율성을 우선시하는 비연결형 통신 방식의 프로토콜입니다. 패킷 사이 순서를 보장하지 않고 수신 여부를 확인하지 않으며 단순히 데이터만 주는 ‘데이터그램 패킷 교환 방식’을 사용합니다. 그렇기 때문에 신뢰성 보다 연속성이 중요한 실시간 서비스에 자주 사용됩니다. 서버와 클라이언트는 1:1, 1:N, N:M으로 연결 가능하여 브로드캐스트가 가능합니다.

**차이점 1. 3-way handshake**

전송 계층에 속하는 두 프로토콜의 가장 큰 차이점은 `3-way handshake` 과정의 유무입니다. `3-way handshake` 은 신뢰성을 제공하기 위한 과정으로서 TCP 통신에서 사용됩니다. 데이터를 보내기 전에 연결을 확립하기 위해 패킷 요청을 3번 교환하는 것을 의미합니다.

**차이점 2. 헤더 구성요소**

TCP로 전송되는 데이터는 TCP 헤더를 포함하며, 이는 패킷 사이의 순서를 보장하기 위한 정보를 가지기 위해 총 20 byte의 크기를 가집니다. 대표적으로 연결의 제어 정보를 기록하기 위한 Code bit(TCP Control Flags, 6 bit), 훼손 또는 위변조 검사를 위한 Check Sum(6 bit), \*흐름제어를 위한 Window Size (16 bit) 등이 포함됩니다.

UDP로 전성되는 데이터는 데이터그램이라고도 불리는 UDP 헤더를 포함합니다. 이는 64 bit의 작은 크기를 가집니다.

\* 흐름제어: 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하는 것으로 수신자의 버퍼 오버플로우를 방지하는 것입니다.

<br><br>

1-1. **TCP 연결 과정인 3-way handshake, 4-way handshake란 무엇인지, 그리고 각 과정에서 왜 단계 차이가 발생하는지 설명해주세요.**

**3-way handshake**

`3-way handshake` 는 데이터를 보내기 전에 연결을 확립하기 위해 패킷 요청을 3번 교환하는 것으로 TCP 통신에서 사용됩니다. 통신을 하려는 두 컴퓨터는 3번의 패킷 교환에서 각각 아래의 단계를 진행하며 데이터 통신 간 신뢰성과 정확성을 확보합니다.

1. 컴퓨터1에서 컴퓨터2에 **연결 확립 요청(SYN)**
1. 컴퓨터2에서 컴퓨터1에 **연결 확립 응답(ACK)** 과 **연결 확립 요청(SYN)**
1. 컴퓨터1에서 컴퓨터2에 **연결 확립 응답(ACK)**

TCP로 전송되는 데이터는 TCP 헤더를 포함하며, TCP 헤더는 연결의 제어 정보를 기록하기 위한 6비트로 구성된 코드 비트를 가지고 있습니다. **연결 확립 요청**에서는 코드 비트 중 SYN라는 비트를 0에서 1로 활성화시킵니다. 그리고 **연결 확립 응답**을 위해 ACK라는 비트를 0에서 1로 활성화 시키게 됩니다.

<br>

**4-way handshake**

`4-way handshake`는 데이터를 전송한 후 연결을 끊기 위한 4번의 패킷 교환 과정입니다. 이를 위해 TCP 헤더의 코드 비트 중 FIN과 ACK를 사용하여 4번의 패킷 교환 과정을 수행합니다.

1. 컴퓨터1에서 컴퓨터2에 **연결 종료 요청(FIN)**
1. 컴퓨터2에서 컴퓨터1에 **연결 종료 응답(ACK)**
1. 컴퓨터2에서 컴퓨터1에 **연결 종료 요청(FIN)**
1. 컴퓨터1에서 컴퓨터2에 **연결 종료 응답(ACK)**

**두 과정에서 단계가 차이나는 이유**

3-way handshake는 데이터를 전송하기 전 연결 확립을 위한 과정이기 때문에 과정 진행 중 전송되는 데이터는 당연히 존재하지 않습니다. 하지만 4-way handshake에 경우 컴퓨터1에서 연결 종료 요청을 보낸 시점에도 컴퓨터1에 도달하지 못한 지연 패킷이 존재할 수 있습니다. 이러한 경우를 대비하기 위해 연결 종료 요청이 후 **연결 종료 응답**을 먼저 보내어 컴퓨터 1은 TIME_WAIT 상태가 되고, 설정된 시간 이후 **연결 종료 요청**을 컴퓨터 2에 보내게 되며 단계 차이가 발생하게 됩니다.

<br>

---

2. **CORS란 무엇이고, 어떻게 구현할 수 있는지 최대한 자세하게 설명해주세요.**

추가 HTTP 헤더를 사용하여, 한 출처(도메인)에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다. 웹 보안을 강화하기 위해 도입되었으며, 기본적으로는 브라우저에서 실행되는 JavaScript 코드로부터 다른 출처로의 HTTP 요청을 제한합니다.

<br>

---

3. **https://google.com을 입력했을 때 생기는 일에 대해 설명해주세요.**

1\. 브라우저의 URL 분석

프로토콜, 도메인 이름, 포트, 경로, 파라미터 등의 정보로 URL의 문법이 정확한지 검사합니다.

2\. 캐시에서 DNS 기록을 확인

웹 브라우저는 DNS서버에 검색하기 전에 아래의 단계로 캐시에 저장된 DNS 기록들을 먼저 확인합니다.

1\) 브라우저 캐시

브라우저는 내가 이전에 방문한 웹 사이트의 DNS 기록을 브라우저 캐시에 일정 기간 동안 저장하고 있습니다.

2\) OS 캐시

브라우저 캐시에 원하는 DNS 기록이 없다면 OS의 DNS 기록 관련 캐시를 확인합니다.

3\) 라우터 캐시

브라우저 캐시, OS 캐시에도 원하는 DNS 기록이 없을 시 브라우저는 라우터 캐시를 확인합니다.

4\) ISP 캐시

컴퓨터와 라우터 모두 원하는 DNS 기록이 없다면 브라우저는 ISP(Internet Service Provider)에서 DNS 기록을 찾습니다. ISP는 DNS 서버를 가지고 있는데, 해당 서버에서 DNS 기록 캐시를 검색합니다.

3\. ISP DNS 서버의 DNS 쿼리를 이용한 IP 주소 찾기 (DNS Lookup)

DNS 쿼리(DNS Query)의 목적은 웹 사이트에 대한 올바른 IP 주소를 찾을 때까지 인터넷에서 여러 DNS 서버를 검색하는 것이다. 필요한 IP 주소를 찾거나 찾을 수 없다는 오류 응답을 반환할 때까지 한 DNS 서버에 다른 DNS 서버로 검색이 반복적으로 계속되기 때문에 재귀적 질의(Recursive Query)라고도 불립니다. 이러한 상황에서 ISP의 DNS 서버를 DNS 리커서(DNS Recursor)라고 부르며, 다른 DNS 서버는 네임 서버(Name Server)라고 부릅니다.

https://google.com의 경우 먼저 DNS 리커서가 루트 네임 서버에 연결합니다. 루트 네임 서버는 리커서를 ‘.com’ 도메인 네임 서버로 리디렉션합니다. ‘.com’ 네임 서버는 DNS 기록에서 ‘google.com’ 과 일치하는 IP 주소를 찾아 DNS 리커서로 반환하고, 리커서는 이를 브라우저로 다시 보냅니다.

위와 같은 요청(Request)은 내용 및 IP 주소(DNS 리커서의 IP 주소)와 같은 정보를 작은 **데이터 패킷**에 담겨 전송됩니다. 이 패킷은 올바른 DNS 서버에 도달하기 전에 클라이언트와 서버 사이의 여러 **네트워킹 장비**를 통해 이동합니다. 이 장비는 **라우팅 테이블**을 사용하여 패킷이 목적지에 도달할 수 있는 가장 빠른 방법을 알아냅니다. 만약 이동 도중에 패킷이 손실되면, **요청 실패 오류**가 발생하는데, 그렇지 않으면 올바른 DNS 서버에 도달하여 IP 주소를 가져온 후 브라우저로 돌아갑니다.

4\. 전달받은 IP주소를 이용하여 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 html문서를 요청

해당 HTTP 요청 메세지는 TCP를 활용하여 서버로 전송됩니다.

5\. WAS와 데이터베이스에서 웹페이지 작업을 처리

웹 서버는 정적인 파일(HTML, CSS, 이미지 파일) 처리를 담당하고 동적인 페이지 처리를 위해 WAS에게 해당 처리를 요청하게 됩니다. 필요한 데이터 정보를 받기 위해 WAS는 DB에서 그에 맞는 데이터를 요구하고, DB는 생성/조회/수정/삭제 등의 작업을 진행합니다.

6\. WAS에서의 작업 처리 결과들을 웹 서버로 전송하고, 웹 서버는 웹 브라우저에게 html 문서 결과를 전달

7\. www.google.com 맞는 화면이 웹 브라우저에 출력

브라우저 렌더링 과정을 거쳐 화면이 웹 브라우저에 출력됩니다.

<br>

---

4. **http1.1, 2.0, 3.0에 대해 각각 설명해주세요.**

**HTTP/1.1**

매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 이후에 keep-alive라는 옵션으로 여러 개의 파일을 송수신할 수 있습니다. 해당 옵션은 1.0 에도 존재했지만, 1.1에서 표준화가 되어 기본 옵션으로 설정되었습니다.

문서 안에 포함된 다수의 리소스(이미지, css 파일, script 파일)를 처리하려면 대기 시간이 길어지는 HOL Blocking(Head Of Line Blocking) 현상을 가질 수 있는 단점이 있습니다.

**HTTP/2.0**

HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜입니다. 이는 1.x 버전과는 달리 HTTPS 위에서만 동작합니다.

멀티플렉싱이란 여러 개의 스트림을 사용하여 송수신한다는 것입니다. 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 정상적으로 동작할 수 있습니다.

서버 푸시란 HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있었다면, HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스를 푸시하는 것을 말합니다. html에는 css나 js 파일이 포함되기 마련인데 html을 읽으면서 그 안에 들어 있는 css 파일을 서버에서 푸시하여 클라이언트에 먼저 줄 수 있습니다.

**HTTP/3.0**

TCP 위에서 동작하는 HTTP/2와는 달리 QUIC라는 계층 위에서 동작하며, TCP 기반이 아닌 UDP 기반으로 동작합니다. 또한 멀티플렉싱을 가지고 있으며 초기 연결 설정 시 3-way handshake 과정이 없기 때문에 지연 시간 감소라는 장점이 있습니다.
