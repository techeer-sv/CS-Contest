1. **TCP와 UDP 각각의 개념을 설명하고, 둘의 차이를 비교해주세요.**

- TCP는 연결형 서비스로 연결이 성공해야 통신이 가능합니다. 이에 반해 UDP는 비연결형 서비스로 연결 없이 통신이 가능하며 데이터그램 방식을 제공합니다.

    <br>
    
    1-1. **TCP 연결 과정인 3-way handshake, 4-way handshake란 무엇인지, 그리고 각 과정에서 왜 단계 차이가 발생하는지 설명해주세요.**
    
    - 3-Way handshake는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정입니다.
        - 동작 방식
            - (1) Client는 Server에 접속을 요청하는 SYN 패킷을 보냅니다. 이때 Client는는 SYN/ACK 응답을 기다리는 SYN-SENT 상태가 됩니다.
            - (2) Server는 Client에 요청을 받고, 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고, Client는가 다시 ACK으로 응답하여 요청 수락을 확인했다는 응답을 기다리게 됩니다.
            - (3) Client는 Server는의 응답을 확인하고 ACK를 Server는에게 보내게 됩니다. 이후로부터는 연결이 이루어졌으므로 데이터가 오가게 됩니다.
            이때의 Server의 상태가 ESTABLISHED가 되게 됩니다.
    - 3-Way handshake는 TCP 연결을 초기화 할 때 사용된다면, 4-Way handshake는 세션을 종료하기 위해 수행되는 절차입니다.
        - 동작 방식
            - (1) Client가 연결을 종료하겠다는 FIN플래그를 전송합니다.
            - (2) Server는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다리는 TIME_WAIT상태로 진입합니다.
            - (3) Server가 통신이 끝났으면 연결이 종료되었다고 Client에게 FIN 플래그를 전송합니다.
            - (4) Client는 확인 했다는 메시지를 보냅니다.
            네트워크 상에서 FIN 패킷이 유실되어 다시 전송되거나, 이전 연결에 대한 중복 패킷이 도착할 수 있으므로 TIME-WAIT 상태에 진입하게 됩니다.

<br>

---
2. **CORS란 무엇이고, 어떻게 구현할 수 있는지 최대한 자세하게 설명해주세요.**

- CORS란 서로 다른 출처에서 리소스를 공유하는 것으로 허용된 포트 외에서의 접근을 제한해 XSS나 CSRF 등을 통해 중요한 데이터를 빼갈 수 없게 해주는 것입니다.
    - 동작 방식으로는
        - 클라이언트 -> 출발지에서 HTTP 요청 헤더에 Origin 필드를 포함해 서버에 요청합니다.
        - 서버 -> 서버는 해당 리소스에 접근하는 것을 허용하는 출처를 나타내는 Access-control-Allow-Origin 헤더를 응답에 포함시킵니다.
        단, 이 헤더는 클라이언트의 출처와 일치하는 경우에만 브라우저에서 리소스에 접근이 허용됩니다.
        - 브라우저 -> 서버로 받은 Access-Control-Allow-Origin 값과 요청 시 보낸 Origin 값을 비교합니다.
        두 값이 일치하면 리소스에 접근을 허용하고, 그렇지 않으면 차단합니다.
            - 브라우저는 비교를 통해 출처가 일치하는지 여부를 확인하고, 이를 기반으로 응답이 유효한지 판단합니다.
            만약 출처가 일치하지 않거나 허용되지 않은 경우, 브라우저는 CORS 오류를 발생시킵니다.

<br>

---
3. **https://google.com을 입력했을 때 생기는 일에 대해 설명해주세요.**

- 사용자가 https://google.com을 입력하면
    - 웹 브라우저가 google.com을 DNS 서버에서 검색하고, 
    DNS 서버에서 해당 도메인 네임에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달합니다.
    - 브라우저는 전달 받은 정보로 해당 서버와 TCP 연결을 설정합니다.
        - https를 사용하기 때문에 SSL/TLS hand shake 과정이 이루어집니다.
    - TCP 연결이 되었다면, 브라우저는 HTTP 요청 메시지를 생성하고 서버로 전송합니다.
        - 요청 메시지에는 전달 받은 정보(OP주소와 URL 정보)가 담겨있습니다.
    - 서버(구글)에서 도착한 HTTP 요청 메시지는 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색합니다.
        - 검색된 웹 페이지 데이터는 HTTP 응답 메시지를 생성, TCP 프로토콜을 사용해 인터넷을 거쳐 사용자에게 전송됩니다.
        - 이때 HTTPS이므로 서버가 생성한 HTTP 응답 메시지는 암호화되어 브라우저로 전송됩니다.
    - 브라우저에 도착한 HTTP 응답 메시지는 해독하고, 웹페이지 데이터로 변환되어 웹브라우저에 의해 출력되어 사용자가 google 홈페이지를 볼 수 있습니다.
<br>

---
4. **http1.1, 2.0, 3.0에 대해 각각 설명해주세요.**

- HTTP1.1은 한번에 한응답만 처리하도록 구성되었고 이로 인해 동시 전송 문제와 다수의 리소스를 처리하기에 속도와 성능 이슈가 존재합니다.
    - HOL(Head Of Line) Blocking -> 특정 응답의 지연
    - RTT(Round Trip Time) 증가 -> 양방향 지연
        - 헤더가 큽니다. (특히 쿠키)
        - http/1.1의 헤더에는 많은 메타 정보들이 저장되어 있습니다.
        - 무거운 Header 구조
            - 사용자가 방문한 웹페에지는 다수의 http 요청이 발생하게 되는데 이 경우 매 요청시마다 중복된 헤더 값을 전송하게 되어서 각 도메인에 설정된 쿠키 정보도 매 요청시 헤더에 포함되어 전송됩니다.
- HTTP2.0은 HTTP1.1을 개선하기 위해 등장했습니다.
    - 특징
        - Multiplexed Streams -> 한 커넥션에 여러 개의 메시지를 동시에 주고 받을 수 있습니다.
            - 여러 개의 스트림을 사용하면 특정 스트림의 패킷이 손실되어도 해당 스트림에만 영향을 미치고 나머지 스트림은 사용 가능합니다.
        - 요청이 커넥션 상에서 다중화 되므로 HOL Blocking이 발생하지 않습니다.
        - Stream Prioritization -> 요청 리소스 간 의존관계를 설정합니다.
        - Header Compression -> Header 정볼르 HPACK 압축 방식을 이용해 압축합니다.
        - Server Push -> HTML문서 상에 필요한 리소스를 클라이언트 요청 없이 보내줄 수 있습니다.
        - 프로토콜 협상 메커니즘 -> 프로토콜을 선택할 수 있습니다 (HTTP1.1, HTTP2 또는 기타)
        - HTTP 1.1과 높은 호환성을 가집니다 -> 메소드, 상태 코드, URI 및 헤더 필드
        - 페이징 로딩 속도가 향상 되었습니다.
- HTTP3.0의 가장 큰 특징은 TCP가 아닌 UDP를 사용하는 것입니다. HTTP3은 QUIC라는 프로토콜 위에서 돌아가는 HTTP로, QUIC는 Quick UPD Inter Connection의 약자로 UDP를 사용하는 프로토콜입니다.
    - TCP는 3-way Hand sahke, 4way han shake 등 오버헤드와 HOLB 등의 문제를 피할 수 없는 데에 반해 QUIC는 TCP hand shake 과정을 최적화하는 것에 초점을 맞추어 설계되었습니다.
    - QUIC 특징
        - 연결 레이턴시 감소
        - 패킷 손실 감지에 걸리는 시간 단축
        - 멀티플렉싱 지원
            - 여러 개의 스트림을 사용하면 특정 스트림의 패킷이 손실되어도 해당 스트림에만 영향을 미치고 나머지 스트림은 사용 가능합니다.
        - 클라이언트의 IP가 바뀌어도 연결을 유지합니다.
            - TCP는 클라이언트의 IP가 바뀌면 연결이 끊어지고, 재연결을 위해 3-way hand shake를 다시 해야하며 이로 인해 레이턴시가 또 다시 발생합니다.
            - QUIC는 Connection ID를 사용해 서버와 연결을 생성하고, 이는 클라이언트 IP와는 무관하므로 클라이언트 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있습니다.