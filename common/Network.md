1. **TCP와 UDP 각각의 개념을 설명하고, 둘의 차이를 비교해주세요.**

- 답 : 전송계층에서 인터넷은 TCP와 UDP라는 두가지 프로토콜을 갖고 있습니다. 먼저, TCP(Transmission Control Protocol,전송 제어 프로토콜)란 신뢰성있는 데이터 전송을 제공하는 연결 지향 프로토콜을 말합니다. 데이터를 패킷 단위로 나누어 전송을 하며 패킷이 보내진 순서대로 목적지에 도착하는 높은 신뢰성을 보장합니다. 네트워크 혼잡 제어와 sender와 receiver간의 데이터 흐름을 제어해 buffer가 overflow 되지 않도록 안전정인 통신을 제공합니다.

  반면 UDP(User Datagram Protocol,사용자 데이터그램 프로토콜)는 기본적인 기능만 제공하며 연결handshake 는 없습니다. 가장 간단한 전송 프로토콜로 흐름제어, 혼잡제어, 순서, 시간, 처리율, 보안에 대해 모두 보장하지 않는 신뢰할 수 없는 데이터 전송입니다. 연결이 없기에 RTT(Round Trip Time)이 없어 지연이 짧고 프로토콜이 간단하여 빠른 데이터 전송이 가능합니다.

   두 차이 비교 <br>
    
    | 프로토콜 종류 | TCP | UDP |
    | --- | --- | --- |
    | 신뢰성 | 정확한 전송을 보장하기 위해 재전송 및 오류 복구 가능 | 오류 복구 기능 없음, Checksum을 통해 오류 탐지는 가능  |
    | 연결 지향성 | 연결형 서비스  | 비연결형 서비스  |
    | 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식  |
    | 전송 순서 | 전송 순서 보장  | 전송 순서가 바뀔 수 있음  |
    | 헤더 크기 | 최소 20byte(Source Port, Destination Port, SEQ Num, ACK Num, Data Offset, Window Size, Checksum 등 필요)  | 8 byte (Source Port, Destination Port, Length, Checksum )  |

    <br>
    
    1-1. **TCP 연결 과정인 3-way handshake, 4-way handshake란 무엇인지, 그리고 각 과정에서 왜 단계 차이가 발생하는지 설명해주세요.**
    
    - 답 : TCP는 데이터를 주고 받기 전에 sender와 receiver 사이에 handshake과정을 거칩니다. 연결 설정을 하기위해선 3-way handshake를, 연결 해제를 위해 4-way-handshake를 합니다. 이때 handshake 란 연결 설정과 연결하는 매개변수들에 동의하기 위해 교환되는 메시지들을 뜻합니다.

      3-way handshake
      1. **클라이언트에서 소켓 생성 후 서버에 연결 요청(SYN)** : 클라이언트는 서버에 연결요청을 하는데, 이때 클라이언트는 SYN 플래그가 설정된 요청을 보냅니다. 이때 이 세그먼트는 클라이언트의 초기 Sequence 번호를 같이 보냅니다.  &nbsp;
      2. **서버가 연결 요청 수락 및 클라이언트에 응답(SYN-ACK)** : 서버는 소켓 생성후 요청을 기다리다 클라이언트로부터 요청이 오면 연결을 수락하고 리소스(버퍼와 변수등)를 할당해 클라이언트에 연결 요청을 보냅니다. 이때 서버는 자체의 초기 Sequence 번호를 포함하고, 클라이언트의 Sequence 번호에 1을 더한 값을 ACK번호로 설정합니다.  &nbsp;
      3. **클라이언트가 서버에게 응답(ACK)** : 클라이언트가 서버로부터 연결 승인 세그먼트(응답)를 받고 ACK 플래그(서버의 Sequence번호 +1) 가 설정된 요청을 보내고 서버가 이 응답을 받으면 3-way handshake는 완료되고, 양쪽간의 안전한 연결이 설정됩니다.
  
      <br>
  
      4-way handshake
      1. **클라이언트가 연결 종료 요청(FIN)** : 클라이언트가 연결 종료를 하고자 할 때, FIN 요청을 서버에게 보냅니다. 이후 클라이언트는 전송은 불가능하고, receive만 가능한 상태가 됩니다. 
      2. **서버가 연결 종료 요청 수락 및 클라이언트에 응답 (ACK)** : 클라이언트의 연결 종료 요청을 받으면 ACK가 설정된 세그먼트를 보내고, 클라이언트에게 연결 종료를 알립니다. 이때 서버는 데이터 전송도 가능합니다.
      3. **서버가 연결 종료 요청 (FIN)** : 클라이언트는 서버의 응답에 서버 종료까지 대기를 하고, 서버는 더이상 데이터 전송할 것이 없으면 자신도 FIN 플래그를 담은 세그먼트를 클라이언트에게 보냅니다. 
      4. **클라이언트가 연결 종료 요청 수락 및 서버에게 응답 (ACK)** : 클라이언트는 서버의 종료 요청을 받으면 ACK 플래그를 담은 세그먼트를 보내고, 서버에게 연결 종료를 알려줍니다. 서버는 바로 연결이 종료되고, 클라이언트는 2 * max segment lifetime만큼 기다린 후 연결을 종료합니다.

      <br>

      각 단계마다 ACK 번호를 사용하고, Sequence Number를 사용하여 순서대로 연결이 이뤄지도록 보장합니다. 또 4-way handshake는 양쪽이 FIN을 보내고 ACK를 기다려 한쪽이 연결을 먼저 종료하더라도 다른쪽이 데이터를 보낼 수 있도록 안전한 종료를 할 수 있게 합니다. 
      

<br>

---
2. **CORS란 무엇이고, 어떻게 구현할 수 있는지 최대한 자세하게 설명해주세요.**

- 답 : CORS(Cross-Origin Resource Sharing, 교차 출처 리소스 공유 정책)는 웹 브라우저에서 실행되는 스크립트에서 다른 도메인의 리소스를 요청할 때 발생하는 보안 상의 이슈를 다루기 위한 웹 표준입니다. 기본적으로 브라우저는 보안 상의 이유로 동일 출처 정책(Same-Origin Policy)을 따르기 때문에 하나의 서버 연결만 허용하도록 설정되어 있습니다. CORS는 이러한 제한을 완화하여 다른 도메인 간의 자원 공유를 허용하는 것을 말합니다. 이때 출처(Origin)는 Protocol + Host + Port 까지 합친 URL을 의미합니다.

  브라우저의 CORS동작은 먼저 클라이언트에서 HTTP 요청 헤더에 Origin을 담아 전달하고, 서버는 응답헤더에 Access-Control-Allow-Origin을 담아, 이 리소스를 접근하는 것이 허용된 출처 url을 내려보냅니다. 클라이언트는 Origin과 서버가 보내준 Access-Control-Allow-Origin을 비교해 유효한지 안한지 확인후 유효하지 않다면 CORS 에러를 보내주고, 유효한경우 리소스를 가져오게 됩니다. 따라서 서버에서 Access-Control-Allow-Origin 헤더에 허용할 출처를 기재해 클라이언트에 응답을 하면 구현할 수 있습니다. 

<br>

---
3. **https://google.com을 입력했을 때 생기는 일에 대해 설명해주세요.**

- 답 : 먼저 브라우저는 URL에 적힌 값을 프로토콜, 도메인, 포트, 경로 등으로 파싱하여 HTTP Request Message를 생성하여 서버에 전송합니다. 브라우저는 DNS Lookup을 수행하여 도메인에 해당하는 IP 주소를 찾습니다. 브라우저, hosts 파일, DNS Cache, 로컬 네트워크 내의 DNS 서버 등에서 매칭되는 IP를 찾고 처음 들어가가거나 캐시 미스가 발생시 루트 도메인 서버부터 서브 도메인 서버 순서로 찾게 됩니다. HTTP Request Message는 패킷으로 변환되어 LAN 어뎁터를 통해 전송이 되고, 이 패킷은 스위칭 허브와 라우터 등을 경유하여 ISP를 통해 인터넷으로 전송됩니다. 패킷은 이때 여러 라우터를 거치게 되는데 각 라우터들은 패킷의 목적지로 가기위한 최적의 경로를 결정합니다. 목적지 LAN에 도착한 패킷은 방화벽을 거치며 보안 검사를 받습니다. 패킷이 웹서버에 도착하며 프로토콜 스택이 패킷을 추출하여 메시지를 복원하여 웹 서버 애플리케이션에 전달합니다. 서버는 해당 요청에 대한 응답 데이터를 작성하여 클라이언트로 보내고, 이 데이터는 전달된 방식 그대로 클라이언트로 전송됩니다. 브라우저는 받은 응답 데이터를 처리하여 웹 페이지를 렌더링하고, 화면에 표시합니다. 

<br>

---
4. **http1.1, 2.0, 3.0에 대해 각각 설명해주세요.**

- 답 : HTTP는 클라이언트와 서버 간의 데이터를 전송하는데 사용되는 프로토콜 입니다. HTTP의 가장 큰 특징은 TCP상에서 동작한다는 것과, 클라이언트의 이전 상태 정보를 갖고 있지 않는 'stateless' 하다는 것입니다.

  HTTP/1.1 버전은 1997년부터 표준화된 HTTP의 첫번째 공식 버전으로 지속적인 TCP 연결을 이용해 서버에서 클라이언트로 보내지는 웹페이지당 하나의 TCP 만을 허용합니다. 하나의 TCP가 지속적인 연결을 하기에 연결내에서 파이프라이닝(pipelined) 요청 기술을 사용하여 여러개의 요청을 이전 요청에 대해 응답이 완료되지 않더라도 미리 다음 요청을 보낼 수 있습니다. 핮지만 서버는 요청이 들어온 순서대로 응답(FCFS) 하기에 HOL 블로킹 문제가 발생할 수 있습니다. 이때 HOL블로킹이란 1개의 큰 request 때문에 뒤에 다른 request들이 오래 기다리는 것을 말합니다. 이 문제 해결을 위해 HTTP/1.1 브라우저에서는 여러개의 병렬 TCP 연결을 열어서 HOL블로킹 문제를 해결합니다. 대부분의 많은 HTTP/1.1 브라우저들은 6개까지의 병렬 TCP 연결을 열 수 있다고 합니다. 

  HTTP/2.0 버전은 2015년에 표준화된 버전으로 주요 목표는 HTTP/1.1 버전의 HOL블로킹 문제 해결을 위해. 하나의 TCP 연결 상에서 멀티플렉싱 요청/응답 지연 시간을 줄이는 것입니다. 1.1 버전과의 차이점은 클라이언트와 서버간의 데이터 포멧 방법과 전송방법입니다. HTTP 메시지에서 보내지는 객체 object들을 frame단위로 쪼개서 stream을 통해 보낸뒤 반대편 사이트에서 재조립하는 것입니다. 모든 프레임은 고정된 길이를 갖습니다. 그리고 stream에 대해 흐름제어와 우선순위 부여 기능을 제공하여   2020년 기준으로 주요 웹사이트의 40%(크롬, 익스플로어,사파리 등)가 사용하고 있다고 합니다.

  HTTP/3.0은 QUIC 위에서 작동하도록 설계된 새로운 HTTP 프로토콜이다. QUIC은 빠른 데이터 전송을 위해 TCP 가 아닌 UDP 위에서 동작하여 클라이언트와 서버의 연결수를 최소화 하고, 패킷혼잡을 피할 수 있다. 또한 UDP이지만 1 handshake가 존재하고, 보안기술을 넣었다. 하지만 아직 더 많은 수정과 발전이 필요하다고 한다. 
