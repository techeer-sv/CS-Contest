## 1. **멀티 프로세스와 멀티 스레드의 개념과 각각의 장단점을 설명해주세요.**

멀티 프로세싱, 멀티 스레딩 모두 하나 어플리케이션에 대한 처리하는 방식입니다.
둘의 이름에 모두 "멀티"가 들어가있다보니 많이 헷갈리고는 하는데, 이에 대한 개념, 그리고 장단점을 기술해보겠습니다.

간단하게 나타내보면 다음과 같습니다.

1. 멀티 프로세싱(Multi Processing)
   - CPU / Memory
     - Process
   - CPU / Memory
     - Process
   - CPU / Memory
     - Process
   - CPU / Memory
     - Process
   - CPU / Memory
     - Process
2. 멀티 스레딩(Multi Threading)
   - CPU / Memory
     - Process
     - Process
     - Process
     - Process
     - Process

이것만 보아도 알 수 있는 사실이 있죠.

1. 멀티 프로세싱은 CPU와 메모리를 작업 개수만큼 분할하고 각각의 작업에 할당하여 여러 작업을 수행하는 것
2. 멀티 스레딩은 CPU와 메모리를 하나의 영역에서 각각의 작업에 유동적으로 배분하여 여러 작업을 수행하는 것

이렇게 이해가 될 수 있습니다.
이제 다시 멀티 프로세싱부터 다시 알아보겠습니다.

### 멀티 프로세싱(Multi Processing)

멀티 프로세싱이란?

- 여러 개의 독립적인 프로세스가 동시에 실행되는 것
- 각 프로세스는 자신만의 메모리(+ CPU)를 할당받는다.

예시

- 컴퓨터에서 VSCode, Chrome, RunCat, Notion 등을 동시에 실행하는 것
- Chrome이 꺼진다고 VSCode에 문제가 생기지는 않는 등의 독립성을 가지고 있음

멀티 프로세스의 장점

- 프로그램 안전성
  - 하나의 프로세스에서 문제가 발생해도 다른 프로세스에 영향을 미치지 않음
- 프로그램 병렬성
  - 여러 프로세스가 동시에 실행되어 작업 처리 속도를 향상시킬 수 있음
- 시스템 확장성
  - 멀티코어 프로세서의 경우 이점을 최대한 활용할 수 있음

멀티 프로세스의 단점

- Context Switching Overhead
  - 프로세스 간 전환할 때 발생하는 오버헤드가 큼
- 자원 공유 비효율성
  - 각 프로세스가 독립된 메모리 공간을 가지므로 자원 공유가 비효율적일 수 있음

### 멀티 스레딩(Multi Threading)

멀티 스레딩이란?

- 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행되는 것
- 프로세스의 자원(메모리)을 공유함

예시

- Chrome 브라우저를 사용하면서 Apple 홈페이지, Team-Joon 소개 페이지, Naver, Google, Tistory, Youtube를 동시에 띄워두는 것이 멀티 스레딩
- 여기서 각각의 탭이 하나의 스레드로 처리될 수 있음

멀티 스레딩의 장점

- 경량성
  - 프로세스보다 생성과 관리할 때 훨씬 가벼운 특징
- 효율적인 자원의 사용
  - 메모리와 자원을 공유하기에 자원 사용이 효율적임
- Context Switching 비용 감소
  - 스레드 간 전환이 프로세스 전환보다 오버헤드가 적음
- 응답시간 단축
  - 동시에 여러 작업을 처리할 수 있기에 빠른 응답시간을 제공

멀티 스레딩의 단점

- 안정성 문제
  - 하나의 스레드에서 문제가 발생할 시 전체 프로세스에 영향을 미칠 수 있음
    - Chrome에서 한 탭에서 메모리가 오버되는 경우 전체적으로 렉걸리는 현상
- 동기화로 인한 성능 저하
  - 공유 자원에 대한 접근을 관리하기 위한 동기화 필요
  - 동기화로 인한 성능 저하
- 데드락(Deadlock)(1-1번, 3번)
  - 여러 스레드가 서로의 응답을 기다리며 진행을 멈추는 현상
  - 하지만 닫힌 루프가 형성되어 기다리기만 해야하죠
- 어려운 디버깅
  - 동시에 여러 스레드가 실행되기에 디버깅을 할 때 그걸 봐야함
- 운영체제의 지원이 필요
  - 효과적으로 멀티 스레딩을 하기 위해서는 운영체제에서의 지원이 필요함

## 1-1. **멀티 스레드 환경에서 스레드는 많으면 많을수록 좋을까요? 이유와 함께 답변해주세요.**

> A. 어느 정도의 필요한 만큼 사용한다고 한다면 작업 효율성을 위해 좋지만 너무 많아지면 복잡성이 증가하면서 아래와 같은 문제들이 발생하기에 스레드가 너무 많아지는 것을 경계해야 한다.

발생하는 문제들

1. **잠김(Lock) 및 레이스 컨디션(Race Condition)**
   - 두 개 이상의 스레드가 동시에 공유 자원에 접근하려고 할 때, 예측불가능한 결과를 초래하는 상황
   - **예방법**
     - **세마포어(Semaphore)**
       - 공유 자원에 대한 접근을 제한하는 카운터
       - 여러 스레드가 동시에 자원에 접근할 수 있는 수를 조절함
     - **뮤텍스(Mutex)**
       - 상호 배제를 위해 사용됨
       - 한 번에 하나의 스레드만 공유 자원에 접근할 수 있도록 함
2. **데드락(Deadlock)**
   - 3번 문제에서 계속 . . .
3. **스타베이션(Starvation)**
   - 일부 스레드가 자원을 과도하게 점유하여 다른 스레드가 자원을 사용하지 못하는 상황
     - 작업 시작 자체를 못한다는 부분에서 데드락과 차이가 존재함
   - **해결책**
     - 스레드에 우선순위를 부여
     - 자원 할당에 대해 공정한 접근 방식을 적용
4. **라이브 록(Live Lock)**
   - 스레드들이 서로를 기다리는 대신 계속 상태를 변경하지만 실제로는 아무런 진전이 없는 상황
   - **해결책**
     - 라이브락 상태를 감지
     - 스레드들이 자원에 대한 접근 방식 변경하도록 하기
5. **기타 예측불가능한 오류(Nondeterminism)**
   - 같은 코드에 대해 실행할 때마다 다른 결과가 나오는 상황입니다.
   - **해결책**
     - 코드의 동시 접근을 제한
     - 스레드 간의 통신을 명확하게 정의

**References**
[👩‍💻 멀티 프로세스 vs 멀티 스레드 비교 💯 완전 총정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-multi-process-multi-thread)
[멀티 프로세스(Multi Process)와 멀티 스레드(Multi Thread)](https://wooody92.github.io/os/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C/)
[멀티 스레드(Multi Thread) & 멀티 프로세스(Multi process)](https://velog.io/@xxhaileypark/%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9CMulti-Thread-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4Multi-process)
[(OS)멀티 프로세스와 멀티 스레드의 차이는 무엇일까?](https://livenow14.tistory.com/67)
[🤔 스레드를 많이 쓸수록 항상 성능이 좋아질까?](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-Is-more-threads-always-better)
[CHAP 08. 스레드 때문에(스레드에서) 발생하는 문제들](https://incheol-jung.gitbook.io/docs/study/with-scouter/chap-08.)
[다중 스레드 코드에서 발생할 수 있는 11가지 문제의 해결](https://dataonair.or.kr/db-tech-reference/d-lounge/technical-data/?mod=document&uid=237271)
[Race Condition과 예방할 방법(세마포어, 뮤텍스)](https://iredays.tistory.com/125)
[(위키)기아 상태](https://ko.wikipedia.org/wiki/%EA%B8%B0%EC%95%84_%EC%83%81%ED%83%9C#:~:text=%EA%B8%B0%EC%95%84%20%EC%83%81%ED%83%9C(starvation%20%EC%8A%A4%ED%83%80%EB%B2%A0%EC%9D%B4%EC%85%98,%EC%97%90%EC%84%9C%20%EB%A7%88%EC%A3%BC%EC%B9%98%EB%8A%94%20%EB%AC%B8%EC%A0%9C%EC%9D%B4%EB%8B%A4.)
[Starvation 과 Deadlock의 차이](https://junco.tistory.com/118)

---

## 2. **컨텍스트 스위칭이란 무엇인지, 그리고 컨텍스트 스위칭으로 인한 문제가 무엇이 있는지 최대한 자세하게 설명해주세요.**

(Q&A GPT 사용)

### 컨텍스트 스위칭이란?

컨텍스트 스위칭은 CPU가 현재 실행 중인 프로세스나 스레드를 중단하고 다른 프로세스나 스레드로 전환하는 과정입니다.
CPU는 현재 실행 중인 작업의 상태(컨텍스트)를 저장하고, 다음 작업의 상태를 불러와야 할 때 발생하죠.

#### 컨텍스트의 구성 요소

1. 프로세스의 프로그램 카운터, 레지스터 값들
2. 메모리 관리 정보 (메모리 할당 상태)
3. 프로세스의 상태 정보 등

### 컨텍스트 스위칭이 일어나는 경우

- 인터럽트 발생 시 (예: I/O 요청, 타이머 인터럽트)
  1.  **I/O 인터럽트**
      - 프로세스가 파일 읽기/쓰기 같은 I/O 작업을 요청
      - 이 작업이 완료될 때까지 CPU는 다른 프로세스로 전환할 수 있음
  2.  **시스템 콜**
      - 사용자 프로세스가 운영 체제의 서비스(예: 파일 시스템 접근, 네트워크 통신)를 요청할 때 시스템 콜 발생
      - 이 시점에서 컨텍스트 스위칭이 일어날 수 있음
- 멀티태스킹 환경에서 CPU 스케줄링에 의해
  - **CPU 스케줄링**은 여러 프로세스가 CPU를 공유하며 효율적으로 작동할 수 있도록 도움
  - 시스템의 전반적인 처리량을 증가시키고, 사용자에게 더 나은 응답 시간 제공
- 사용자의 프로세스가 시스템 콜을 사용할 때

### 컨텍스트 스위칭의 필요성

멀티태스킹 환경에서는 컨텍스트 스위칭이 필수적입니다. 이를 통해 여러 프로세스와 스레드가 CPU 자원을 공유하며 동시에 실행되는 것처럼 보이게 만들어줍니다.
컨텍스트 스위칭을 통해 시스템의 응답성을 높이고, 리소스 사용을 최적화할 수 있습니다.

라고 지금까지 희망편을 보셨는데요, 이로 인한 문제점들도 분명히 존재합니다. 아래에서 확인해보겠습니다.

### 컨텍스트 스위칭으로 인한 문제점

1. **오버헤드 발생**
   - 컨텍스트 스위칭은 CPU가 실제 작업을 수행하는 대신 상태 정보를 저장하고 불러오는 데 시간을 소비하며, 이로 인해 시스템의 전반적인 성능이 저하될 수 있음
1. **메모리 캐시 효율성 감소**
   - 새로운 프로세스로 전환하면 이전 프로세스의 메모리 캐시 내용이 무효화됩니다. 이는 캐시 미스를 증가시키고, 메모리 접근 시간이 늘어나게 합니다.
     - Q. 그런데 이건 초당 최소 100번 이상 일어난다면서? 그럼 캐시를 굳이 저장해야해?
     - A. 컨텍스트 스위칭이 자주 발생하면 메모리 캐시의 효율성이 감소할 수 있습니다. 캐시 미스가 빈번하게 발생하면, 시스템은 더 느려질 수 있으며, 이는 성능 저하로 이어집니다.
1. **CPU 사용률 감소**
   - 자주 발생하는 컨텍스트 스위칭은 CPU가 실제 작업에 할당하는 시간을 줄여, CPU 사용률을 감소시킬 수 있습니다.
     - Q. CPU 사용률을 줄이면 리소스를 아낄 수 있어서 좋은 거 아니야?
     - A. 컨텍스트 스위칭이 CPU 사용률을 줄이는 것은 리소스를 절약한다기보다는 CPU가 효율적으로 활용되지 못하는 상황을 의미합니다. 이는 CPU가 실제 작업을 처리하는 대신 상태를 전환하는 데 시간을 소비하기 때문입니다.
1. **이식성 문제**
   - 컨텍스트 스위칭은 대체로 어셈블리어로 작성되어 있기에, 새로운 CPU 아키텍처가 등장할 때마다 새로 작성해야 하는 이식성 문제를 발생시킴
     - Q. 어셈블리어로 작성하면 그 코드를 그대로 사용하지 못하는 거야?
     - A. 어셈블리어로 작성된 코드는 특정 CPU 아키텍처에 매우 밀접하게 연결되어 있습니다. 새로운 아키텍처가 등장하면, 이 코드를 새로운 아키텍처에 맞게 수정해야 합니다. 이는 소프트웨어의 이식성을 제한하는 요인이 됩니다.

**References**
[운영체제 5: 컨텍스트 스위칭 (Context Switching)](https://hyunie-y.tistory.com/31)
[컨텍스트 스위칭이란](https://applefarm.tistory.com/105)
[컨텍스트 스위치(Context Switch)란?](https://uzun.dev/92)
[(운영체제(OS)) 프로세스와 컨텍스트 스위칭(Context Switching)이란?](https://resilient-923.tistory.com/217)](https://resilient-923.tistory.com/217)
[Context Switching 이란?](https://velog.io/@curiosity806/Context-Switching%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-process%EC%99%80-thread)

---

## 3. **데드락에 대해 설명하고, 해결 방법을 아는대로 설명해주세요.**

> 데드락입니다! DeadLock, 죽었어요! + 잠겼어요!

무슨 의미일까요?
영어단어 그대로입니다. 잠겨서 죽은 어떤 한 사이클입니다.
일단 실행은 되었으며, 어떤 순환을 돌았으나, 갑자기 탈출구를 찾지 못하는 기이한 현상이 벌어집니다.
마치 사물함에 열쇠를 넣고 잠그는 것처럼 말이죠.

이제 기술적으로 알아보도록 하겠습니다.

> 데드락은 무엇일까요?

데드락(Deadlock)이란 멀티태스킹 시스템에서 여러 프로세스가 서로가 점유한 자원을 요청하면서 무한 대기 상태에 빠지는 현상을 말합니다.
이 상태에서는 각 프로세스가 서로의 자원을 기다리며, 아무것도 진행할 수 없게 되기에 시스템의 작업 처리가 멈춥니다.

> 데드락이 발생하기 위한 필수 조건이 있다고요?

네 맞습니다. 무려 4가지의 필수 조건이 존재하는데요, 이는 다음과 같습니다.

1. **상호 배제(Mutual Exclusion)**: 자원은 한 번에 한 프로세스만이 사용할 수 있어야 합니다.
2. **점유 대기(Hold and Wait)**: 프로세스는 최소한 하나의 자원을 점유한 상태에서, 다른 프로세스가 점유한 자원을 추가로 점유하기 위해 대기해야 합니다.
3. **비선점(No Preemption)**: 프로세스가 점유하고 있는 자원은 강제로 빼앗을 수 없어야 합니다.
4. **순환 대기(Circular Wait)**: 프로세스들이 순환 형태로 각자 다음 프로세스가 요구하는 자원을 점유하고 있어야 합니다.

> 이렇게 복잡한 필수 조건이 만족되면서까지 데드락에 어쩌다가 걸리셨다고요? 걱정 마세요!

예방법이 분명 존재하고, 회피 방법도 존재합니다.

1. 데드락 예방 및 회피(Prevention and Avoidance)
   - 상호 배제 부정
     - 여러 프로세스가 자원을 공유할 수 있도록 함
   - 점유 대기 부정
     - 프로세스가 실행 전 필요한 모든 자원을 한번에 요청하도록 함
   - 비선점 부정
     - 프로세스가 다른 자원을 요청할 때 이미 점유하고 있는 자원을 반납하고 기다림
   - 순환 대기 부정
     - 자원에 고유한 번호를 할당하고 순서대로 자원을 요청하게 함
   - 은행원 알고리즘
     - 프로세스의 자원 요구가 시스템의 안정 상태를 유지할 수 있는지 사전에 검사하여 데드락을 회피함

위에서 본 4가지 필수조건을 회피하는 방법과 다소 특이한 은행원 알고리즘을 사용하는 방법이 있습니다.
또한 데드락을 미리 감지하고 회복시킬 방법들도 아래와 같이 존재합니다.

2. 데드락 탐지 및 회복(Detection and Recovery)
   - 자원 할당 그래프를 이용한 데드락 탐지
     - Q. 자원 할당 그래프를 보면 데드락인지 아닌지를 어떻게 확인하죠?
     - A. 답변(GPT)
       1. **그래프의 구성**
          - 자원 할당 그래프는 노드(node)와 엣지(edge)로 구성됩니다.
          - 노드는 두 종류로 나뉘며, 하나는 프로세스(P), 다른 하나는 자원(R)을 나타냅니다.
          - 엣지는 프로세스와 자원 간의 관계를 나타내며, 요청 엣지(request edge)와 할당 엣지(allocation edge) 두 종류가 있습니다.
          - **요청 엣지**
            - 프로세스에서 자원으로 가는 방향으로, 프로세스가 해당 자원을 요청하고 있음을 나타냅니다.
          - **할당 엣지**
            - 자원에서 프로세스로 가는 방향으로, 자원이 프로세스에 할당되어 있음을 나타냅니다.
       2. **데드락의 징후 확인**
          - 데드락이 발생하는 경우, 자원 할당 그래프에서 순환(cycle)이 발생합니다.
          - 즉, 특정 시작점에서 시작한 엣지의 순서가 결국 같은 시작점으로 되돌아오는 경우입니다.
          - 순환은 프로세스들이 서로를 대기하고 있는 상태를 나타내며, 이러한 순환은 데드락의 주요 징후입니다.
       3. **순환의 확인**
          - 그래프에서 순환을 확인하기 위해, 모든 노드를 조사하면서 순환을 찾아봅니다.
          - 만약 순환을 발견하면 데드락이 발생했다고 판단할 수 있습니다.
          - 그러나 모든 순환 구조가 데드락을 의미하는 것은 아니며, 순환 구조 내의 모든 프로세스가 자원을 추가로 요구하고 있을 때만 데드락 상태라고 할 수 있습니다.
       4. **단순성 검사**
          - 그래프가 매우 단순하고 프로세스와 자원 수가 적은 경우, 순환 구조는 눈으로 쉽게 확인할 수 있습니다.
          - 그러나 복잡한 시스템에서는 알고리즘을 통한 자동화된 순환 탐지 방법이 사용됩니다.
       5. **데드락 해결**
          - 데드락이 발생한 것으로 확인되면, 시스템은 데드락을 해결하기 위한 조치를 취해야 합니다.
          - 예를 들어, 일부 프로세스를 종료하거나, 일부 자원을 강제로 회수하는 방법 등이 있습니다.
   - 데드락이 발생하면 프로세스를 강제로 종료하거나 선점하여 자원 회수
   - 우선 순위가 낮은 프로세스, 수행 횟수가 적은 프로세스 등을 위주로 프로세스의 자원을 선점

**References**
[Deadlock 개념이란? 그에 대한 해결책/회피책](https://jwprogramming.tistory.com/12)
[(운영체제) 데드락(Deadlock, 교착 상태)이란?](https://chanhuiseok.github.io/posts/cs-2/)
[데드락 (DeadLock, 교착 상태)](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html)
