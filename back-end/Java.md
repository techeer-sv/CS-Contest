1. **자바의 실행 과정을 JIT 컴파일러와 인터프리터 키워드를 포함하여 설명해주세요.**

- 답 : 

  **자바 프로그램의 실행 3단계 : 컴파일, 로드, 실행**

  **1. 컴파일 단계**

    자바 컴파일러(javac)가 소스 코드를 바이트 코드로 컴파일한다. 이 바이트 코드는 플랫폼에 독립적이다.

  **2. 로드 단계**

  JVM은 클래스 로더를 통해 컴파일된 바이트 코드를 읽는다. 클래스 로더는 필요한 클래스들을 로드하고 메모리에 올린다.

  **3. 실행 단계**

  Execution Engine은 로드된 바이트 코드를 해석하고 실행합니다. 이 과정에서 프로그램 수행 속도를 위하여, Interpreter을 이용하여 프로그램을 한 줄씩 실행함과 동시에 JIT 컴파일러를 사용하여 바이트 코드를 기계어로 컴파일하여, 실행이 지나치게 느려지지 않도록 한다.

<br>

---
2. **해시의 개념과 해시를 사용할 때 발생할 수 있는 문제를 설명하고, 자바가 이를 해결하는 방법이 무엇인지 최대한 자세하게 설명해주세요.**

- 답 :

    해시는 입력받은 데이터를 고정된 길이의 값으로 변환하는 것을 말한다.
    무한한 종류의 대이터의 유한한 공간으로 mapping 하는 것이기 때문에, 충돌은 불가피하고, 자바는 이를 Seperate Chaining 과 Open addressing 기법으로 해결한다.  

    **개방 주소법(open addressing)** : 해시 테이블 크기는 고정하면서 저장할 위치를 찾는다.  
    **분리 연결법 (separate chaining)** : 해시 테이블의 크기를 유연하게 만든다.


  <br>
    
   2-1. **Hashtable, HashMap, ConcurrentHashMap에 대해 설명하고, ConcurrentHashMap이 어떻게 성능을 개선하였는지 설명해주세요.**

  - 답 : 

    **HashMap**  
    - Null 허용
    - 동기화 미보장
    - 동기화를 처리하지 않기 때문에 데이터를 탐색하는 속도가 빠르다.
    
    **HashTable**
    - Null 비허용
    - 모든 데이터 조작 메서드에 synchronized 키워드가 적용되어 동기화 락을 걸어 스레드 안정성을 보장한다.
    - 모든 메서드에 락을 걸어 처리하기 때문에 성능이 떨어질 수 있다.

    **ConcurrentHashMap**
    - Null 비허용
    - 스레드 안전성을 보장한다.
    - Entry 아이템별로 락을 걸어 HashMap의 동기화 문제를 개선하고, HashTable의 성능 문제을 개선했다.


    <br>

---
3. **가비지 컬렉션의 개념과 동작 원리, 그에 따른 장단점에 대해 설명해주세요.**

- 답 :

    가비지 컬렉션은 Heap 영역에서 동적으로 할당된 메모리 중 필요없게 된 메모리 객체(garbage)를 주기적으로 제거하는 프로세스이다.

    Java 에서는 JVM 이 이를 담당하며, Python, JavaScript, Go 등 많은 언어에서 이 기능을 지원하며, C/C++ 에서 free(), delete() 함수를 주기적으로 수행하는 프로세스 라고 볼 수 있다.

    자동으로 메모리 관리를 해주기 때문에 안정성과 편의성이 높지만, 별도의 메모리와 자원 소모가 필요해 성능 저하가 된다는 단점이 있다.

  <br>

---
4. **Java IO와 NIO의 차이와, NIO가 IO를 개선한 방법에 대해 설명해주세요.**

- 답 : 

  IO 와 NIO 는 다음과 같은 차이점이 있다

  1. 스트림 vs 채널  
  - IO는 스트림 기반이고, 입력 스트림과 출력 스트림이 분리되어 있다.
  때문에, 데이터를 읽기 위해 입력과 출력 스트림 2가지를 만들어야 한다.  
  - NIO는 채널 기반이다. 채널은 스트림과 달리 입력과 출력이 모두 하나의 채널로 가능하다.

  2. Non-Buffer vs Buffer
  - IO에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽는다. 때문에 속도가 느리다. 또한 IO는 스트림에서 읽은 데이터를 즉시 처리하므로 스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않으면, 입력된 데이터의 위치를 이동해 가면서 자유롭게 이용할 수 없다.
  - NIO는 기본적으로 버퍼를 사용하여 입출력을 한다. 채널은 버퍼에 저장된 데이터를 출력하고, 입력된 데이터를 버퍼에 저장한다. 때문에 IO에 비해 빠르고, 읽은 데이터를 무조건 버퍼에 저장하기 때문에 버퍼 내에서 데이터의 위치를 이동해 가면서 필요한 부분만 읽고 쓸 수 있다.